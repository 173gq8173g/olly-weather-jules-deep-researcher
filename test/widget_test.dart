import 'package:flutter/material.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:flutter_weather_app/login_screen.dart';
import 'package:flutter_weather_app/main.dart';
import 'package:flutter_weather_app/models/weather_info.dart';
import 'package:flutter_weather_app/services/weather_service.dart';
import 'package:flutter_weather_app/weather_screen.dart';
import 'package:geolocator/geolocator.dart';
import 'package:http/http.dart' as http;
import 'package:mockito/annotations.dart';
import 'package:mockito/mockito.dart';

// Generate mocks for WeatherService and http.Client
@GenerateMocks([WeatherService, http.Client])
import 'widget_test.mocks.dart'; // Will be generated by build_runner

// Golden master API Key to use in tests where service is not fully mocked for this.
const String testApiKey = "TEST_API_KEY_123"; // Changed to lowerCamelCase

// MockWeatherServiceAltered class is removed. We will use the generated MockWeatherService.


void main() {
    // const originalApiKey = openWeatherMapApiKey; // Unused variable removed

  setUpAll(() {
      // Nothing to do here for now, API key is handled by mocks or direct const reference.
  });

  tearDownAll(() {
      // Nothing to do here for now.
  });


  testWidgets('Login screen UI elements are present', (WidgetTester tester) async {
    await tester.pumpWidget(const MyApp());

    expect(find.text('Weather App Login'), findsOneWidget);
    expect(find.widgetWithText(TextFormField, 'Email / Username'), findsOneWidget);
    expect(find.widgetWithText(TextFormField, 'Password'), findsOneWidget);
    expect(find.widgetWithText(ElevatedButton, 'Login'), findsOneWidget);
  });

  testWidgets('Login fails with empty fields and shows validation error', (WidgetTester tester) async {
    await tester.pumpWidget(const MyApp());

    await tester.tap(find.widgetWithText(ElevatedButton, 'Login'));
    await tester.pump(); // Process validation

    expect(find.text('Please enter your email or username'), findsOneWidget);
    expect(find.text('Please enter your password'), findsOneWidget);
  });

  testWidgets('Login succeeds with non-empty fields and navigates to WeatherScreen', (WidgetTester tester) async {
    // Use the generated MockWeatherService
    final mockWeatherService = MockWeatherService();

    // Stub the methods for this test case
    when(mockWeatherService.getCurrentLocation()).thenAnswer((_) async =>
      Position(latitude: 10, longitude: 10, timestamp: DateTime.now(), accuracy: 1, altitude: 1, altitudeAccuracy: 1, heading: 1, headingAccuracy: 1, speed: 1, speedAccuracy: 1)
    );
    when(mockWeatherService.fetchWeather(position: anyNamed('position'))).thenAnswer((_) async =>
      WeatherInfo(
        cityName: 'Mockville',
        temperature: 22.0,
        description: 'Clear Sky',
        iconCode: '01d',
        humidity: 55,
        windSpeed: 3.3,
      )
    );

    await tester.pumpWidget(
      MaterialApp(
        initialRoute: LoginScreen.routeName,
        routes: {
          LoginScreen.routeName: (context) => const LoginScreen(),
          WeatherScreen.routeName: (context) => WeatherScreen(weatherService: mockWeatherService),
        },
      )
    );

    // Enter text
    // Find the TextFormField by looking for the one that is an ancestor of the specific label text.
    await tester.enterText(find.ancestor(
      of: find.text('Email / Username'),
      matching: find.byType(TextFormField)
    ), 'test@example.com');
    await tester.enterText(find.ancestor(
      of: find.text('Password'),
      matching: find.byType(TextFormField)
    ), 'password123');
    await tester.pump();

    // Tap login
    await tester.tap(find.widgetWithText(ElevatedButton, 'Login'));
    await tester.pumpAndSettle(); // Wait for navigation and WeatherScreen to load

    // Verify on WeatherScreen
    expect(find.text('Current Weather'), findsOneWidget); // AppBar title
    expect(find.text('Mockville'), findsOneWidget);
    expect(find.text('22.0°C'), findsOneWidget);
    expect(find.text('Clear Sky'), findsOneWidget);
  });

  testWidgets('WeatherScreen shows loading indicator then weather data', (WidgetTester tester) async {
    final mockService = MockWeatherService();
    when(mockService.getCurrentLocation()).thenAnswer((_) async =>
      Position(latitude: 1, longitude: 1, timestamp: DateTime.now(), accuracy: 0, altitude: 0, altitudeAccuracy: 0, heading: 0, headingAccuracy: 0, speed: 0, speedAccuracy: 0)
    );
    when(mockService.fetchWeather(position: anyNamed('position'))).thenAnswer((_) async =>
      WeatherInfo(
        cityName: 'Sunnydale',
        temperature: 25.0,
        description: 'Very Sunny',
        iconCode: '01d',
        humidity: 40,
        windSpeed: 2.0
      )
    );

    await tester.pumpWidget(MaterialApp(home: WeatherScreen(weatherService: mockService)));

    // Initially, it might be loading (or already past it if mock is too fast)
    // If the mock is synchronous or very fast, CircularProgressIndicator might not be visible long enough.
    // We expect data to appear after pumpAndSettle.

    expect(find.byType(CircularProgressIndicator), findsOneWidget);
    await tester.pumpAndSettle(); // Let Future in initState complete

    expect(find.text('Sunnydale'), findsOneWidget);
    expect(find.text('25.0°C'), findsOneWidget);
    expect(find.text('Very Sunny'), findsOneWidget);
    expect(find.byType(Image), findsOneWidget); // Weather Icon
  });

  testWidgets('WeatherScreen shows error message if API key is missing', (WidgetTester tester) async {
    final mockService = MockWeatherService();
    // For this test, getCurrentLocation can succeed or doesn't matter as fetchWeather should fail first.
    when(mockService.getCurrentLocation()).thenAnswer((_) async =>
      Position(latitude: 0, longitude: 0, timestamp: DateTime.now(), accuracy: 0, altitude: 0, altitudeAccuracy: 0, heading: 0, headingAccuracy: 0, speed: 0, speedAccuracy: 0)
    );
    // Stub fetchWeather to throw the API key missing error
    when(mockService.fetchWeather(position: anyNamed('position'))).thenThrow(
      Exception('API Key Missing: Please replace "YOUR_API_KEY_HERE"')
    );
    // Also stub fetchWeatherByCityName if it might be called as a fallback, to throw the same error
    when(mockService.fetchWeatherByCityName(any)).thenThrow(
      Exception('API Key Missing: Please replace "YOUR_API_KEY_HERE"')
    );

    await tester.pumpWidget(MaterialApp(home: WeatherScreen(weatherService: mockService)));
    await tester.pumpAndSettle();

    expect(find.textContaining('API Key Missing'), findsOneWidget);
    expect(find.widgetWithText(ElevatedButton, 'Try Again'), findsOneWidget);
  });

   testWidgets('WeatherScreen shows error and falls back to default city on general API error', (WidgetTester tester) async {
    final mockService = MockWeatherService();

    // Mocking getCurrentLocation to succeed initially
    when(mockService.getCurrentLocation()).thenAnswer((_) async =>
      Position(latitude: 1, longitude: 1, timestamp: DateTime.now(), accuracy: 0, altitude: 0, altitudeAccuracy: 0, heading: 0, headingAccuracy: 0, speed: 0, speedAccuracy: 0)
    );

    // Mocking fetchWeather to fail the first time it's called with a position
    when(mockService.fetchWeather(position: anyNamed('position'))).thenThrow(Exception('Simulated API Network Error'));

    // Mocking fetchWeatherByCityName to succeed for the fallback
    when(mockService.fetchWeatherByCityName(defaultCityName)).thenAnswer((_) async =>
      WeatherInfo(
        cityName: defaultCityName, // London
        temperature: 12.0,
        description: 'Default Cloudy',
        iconCode: '03d',
        humidity: 70,
        windSpeed: 4.0
      )
    );

    await tester.pumpWidget(MaterialApp(home: WeatherScreen(weatherService: mockService)));

    // Initial load
    expect(find.byType(CircularProgressIndicator), findsOneWidget);
    await tester.pumpAndSettle(); // Process initial fetch (which will fail) and fallback

    // Verify error message about the failure and fallback is shown
    expect(find.text("Showing default due to API error: Simulated API Network Error"), findsOneWidget);

    // Verify weather for the default city is displayed
    expect(find.text(defaultCityName), findsOneWidget); // e.g., London
    expect(find.text('12.0°C'), findsOneWidget);
    expect(find.text('Default Cloudy'), findsOneWidget);
    expect(find.widgetWithText(ElevatedButton, 'Try Again'), findsNothing); // Error should be informational, not blocking
  });


  testWidgets('WeatherScreen shows error message on location failure and falls back', (WidgetTester tester) async {
    final mockService = MockWeatherService();

    // Mock getCurrentLocation to throw an error
    when(mockService.getCurrentLocation()).thenThrow(Exception('Simulated Location Permission Denied'));

    // Mock fetchWeatherByCityName for the fallback
    when(mockService.fetchWeatherByCityName(defaultCityName)).thenAnswer((_) async =>
      WeatherInfo(
        cityName: defaultCityName,
        temperature: 10.0,
        description: 'Foggy Default',
        iconCode: '50d',
        humidity: 90,
        windSpeed: 1.0
      )
    );

    await tester.pumpWidget(MaterialApp(home: WeatherScreen(weatherService: mockService)));
    await tester.pumpAndSettle();
    await tester.pump(const Duration(milliseconds: 200)); // Extra pump for good measure after SnackBar activities

    // Check for SnackBar first (might be harder to test reliably without more complex setup)
    // For now, check the main error message area and successful fallback
    // expect(find.textContaining('Location Error: Simulated Location Permission Denied'), findsOneWidget); // This would be for the SnackBar
    expect(find.text("Showing weather for default location due to location error."), findsOneWidget);
    expect(find.text(defaultCityName), findsOneWidget);
    expect(find.text('10.0°C'), findsOneWidget);
    expect(find.text('Foggy Default'), findsOneWidget);
  });

  testWidgets('Refresh button fetches new weather data', (WidgetTester tester) async {
    final mockService = MockWeatherService();

    // Initial setup: getCurrentLocation and fetchWeather succeed
    when(mockService.getCurrentLocation()).thenAnswer((_) async =>
      Position(latitude: 0, longitude: 0, timestamp: DateTime.now(), accuracy: 1, altitude: 0, altitudeAccuracy: 1, heading: 0, headingAccuracy: 1, speed: 0, speedAccuracy: 1)
    );
    // Initial call
    when(mockService.fetchWeather(position: anyNamed('position'))).thenAnswer((_) async =>
      WeatherInfo(cityName: 'Initial City', temperature: 20, description: 'Initial', iconCode: '01d', humidity: 50, windSpeed: 2)
    );

    await tester.pumpWidget(MaterialApp(home: WeatherScreen(weatherService: mockService)));
    await tester.pumpAndSettle();

    expect(find.text('Initial City'), findsOneWidget);
    expect(find.text('20.0°C'), findsOneWidget); // Initial temp

    // Configure the mock for the NEXT call to fetchWeather (simulating refresh)
    // This needs to be a separate `when` or update the existing one if Mockito supports sequential stubs easily,
    // but for clarity, a new when for the specific interaction during refresh is better.
    // Since getCurrentLocation will be called again on refresh, stub it again too.
    when(mockService.getCurrentLocation()).thenAnswer((_) async =>
      Position(latitude: 0, longitude: 0, timestamp: DateTime.now(), accuracy: 1, altitude: 0, altitudeAccuracy: 1, heading: 0, headingAccuracy: 1, speed: 0, speedAccuracy: 1)
    );
    when(mockService.fetchWeather(position: anyNamed('position'))).thenAnswer((_) async {
      await Future.delayed(const Duration(milliseconds: 50)); // Simulate network delay
      return WeatherInfo(cityName: 'Refreshed City', temperature: 25.5, description: 'Newly Refreshed', iconCode: '02d', humidity: 60, windSpeed: 3);
    });

    // At this point, initial data is loaded, so _isLoading should be false.
    // The refresh button's enabled state depends on this.

    await tester.tap(find.byIcon(Icons.refresh));
    await tester.pump(); // First pump to show loading indicator

    // Check if loading indicator is present
    expect(find.byType(CircularProgressIndicator), findsOneWidget, reason: "CircularProgressIndicator should be visible after tapping refresh and pumping once.");

    await tester.pumpAndSettle(); // Let all frames complete (including the Future.delayed and subsequent rebuilds)

    expect(find.text('Refreshed City'), findsOneWidget);
    expect(find.text('25.5°C'), findsOneWidget); // Check new temp
    expect(find.text('Initial City'), findsNothing);
  });

}
